// Copyright (C) 2018 TomTom NV. All rights reserved.
//
// This software is the proprietary copyright of TomTom NV and its subsidiaries and may be
// used for internal evaluation purposes or commercial use strictly subject to separate
// license agreement between you and TomTom NV. If you are the licensee, you are only permitted
// to use this software in accordance with the terms of your license agreement. If you are
// not the licensee, you are not authorized to use this software in any manner and should
// immediately return or destroy it.

= Testing Fallback Handling Between Situation Handlers

== Status

Implemented

== Context

There is a function `GetHandlers` in the `InstructionEngine` which
contains a static list of `SituationHandlerInterface` instances.  The
order matters - for example it is important that the
`CrossComplexIntersectionHandler` runs before the
`TurnAtComplexIntersectionHandler`, so that it can force no
instruction to be issued when crossing straight through a complex
intersection.

The order in which the handlers run is enshrined in the code [here](https://github.com/tomtom-internal/navigation-instruction-engine/blob/70641ae67b125fe463705cae4758aa501ef4203f/navigation-instruction-engine/test/unit/situation_handlers/situation_handler_sequencer_test.cpp)

We have unit tests that ensure that each situation handler generates
the correct (possibly empty) set of instructions as intended, and also
that it returns `boost::none` in cases where some other situation
handler should be used.  But we do not have unit tests that check that
the situations handlers are run in the correct order.

We do have collaboration tests, i.e. GXL mock map tests, that test the
entire `InstructionEngine` to ensure it gives the correct
instructions.  This does indirectly test that `GetHandlers` has the
situation handlers in the correct order.  But if those tests fail, it
is not immediately clear that there is an issue with the ordering of
the situation handlers, rather than a logical error inside the
situation handlers themselves.  Also it is not clear that we can cover
all the critical cases of ordering within `GetHandlers`, since the GXL
maps are not written with that goal in mind.

There is no unit test of the `InstructionEngine` that test the generic
logic of trying each situation handler in turn.

An important goal of the new instruction engine is explainability.
But with a single static ordering of situation handlers, it is hard to
explain how the ordering was determined.  And it is hard to explain to
customers why a particular instruction was given at a particular time,
since in principle that depends on the detailed behaviour of all the
situation handlers earlier in the list.

The current list of situation handlers is:

* `ControlledAccessExitHandler`
* `RoundaboutHandler`
* `CrossComplexIntersectionHandler`
* `TurnAtComplexIntersectionHandler`
* `TurnHandler`
* `ControlledAccessEntryHandler`

== Alternatives

=== Separate Unit Test for `GetHandlers`

In this approach GetHandlers will be broken out into a separate unit
with its own unit tests.  The completed list of situation handlers
would be dependency-injected into the `InstructionEngine`.  The unit
tests of the `InstructionEngine` would only test the logic of trying
each situation handler in turn.  Those tests will _not_ use the real
list of situation handlers, rather a number of mock situation
handlers.

`GetHandlers` would be tested over a number of pairs of particular
situation handlers, such that one situation handler must appear
earlier in the list than another.  Each test should have comments
explaining why these handlers must appear in that order.  They would
use the `Name()` member of the situation handlers to verify that the
correct one has been used.

=== Use a Factory to Produce Situation Handlers

In this approach we will create a factory that can produce situation
handlers by name.  There would be two alternative implementations of
the factory - a real implementation and a mock implementation.  The
mock implementation would return mock situation handlers that only
record the order in which they are tried.

The unit test for the `InstructionEngine` would use a mock factory.
For a set of pairs of situation handlers, the unit test for the
`InstructionEngine` would test that it attempts the pair of situation
handlers in the correct order.

The unit test for the factory would simply test that for each
situation handler type, the factory produces the correct object.

=== Use SituationHandlerSequencer
In this approach we replace `GetHandlers` function with
`SituationHandlerSequencer` class. `SituationHandlerSequencer` has
only one public function which provides situation handlers one by
one in strictly defined order.
```c++
class SituationHandlerSequencer {
 public:
  const SituationHandlerInterface* GetNext();
};
```
SituationHandlerSequencer class can be easily tested separately.

== Decision

Introduce SituationHandlerSequencer to provide handlers.

== Consequences

* The ordering of situation handlers will not be completely bound
  by tests - multiple orderings may satisfy the logical constraints,
  and therefore the unit tests
* The tests will act as documentation for the logic we rely on to
  determine priority of situation handlers.
* This documentation somewhat helps when explaining how our logic
  behaves, but this implementation is still fundamentally difficult to
  fully explain
