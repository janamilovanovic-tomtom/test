// Copyright (C) 2024 TomTom NV. All rights reserved.

= Setting Announcement Phase in Continuous Mode

== Context

Continuous lane recommendations required a new implementation of the lane
guidance provider, named `LaneGuidanceProviderContinuous`. With this change,
scenario generation is triggered by different events than before. Additionally,
the way we update the upcoming maneuver (and thus announcement phase) has
changed slightly.

== Problem

In the current implementation, the announcement phase of the upcoming maneuver
can be set by both the `SetAnnouncementPhase` method and, under certain
conditions, by the `SetPosition` method. This occurs at the beginning of a new
route when there is no scenario to track yet. In such cases, the `SetPosition`
method sets the first upcoming maneuver (this is done to avoid an invalid
`next_maneuver_segment_id` in the scenario; see
https://tomtom.atlassian.net/browse/NAV-153037[NAV-151910]) and assigns the
announcement phase to `kNoAnnouncement`. However, this operation can
inadvertently overwrite the phase previously set by the `SetAnnouncementPhase`
method. Although this order of requests from Trip is not forbidden, the current
implementation of lane guidance provider does not handle it correctly.
Consequently, this can result in a lane guidance scenario having an invalid
announcement phase, preventing the scenario from being delivered to the end
user; see the bug report
https://tomtom.atlassian.net/browse/NAV-153037[NAV-153037]. The sequence diagram
below illustrates this situation.

[plantuml]
----

@startuml

box #LightBlue
Participant TripService
end box

box
Participant LaneGuidanceProviderContinuous
Participant LaneGuidanceTracker
end box

==New route==

TripService -> LaneGuidanceProviderContinuous: Reset()
LaneGuidanceProviderContinuous -> LaneGuidanceTracker: Reset()
LaneGuidanceTracker -> LaneGuidanceTracker: ResetScenario()\nannouncement_phase = kNoAnnouncement
TripService -> LaneGuidanceProviderContinuous: SetScenarioInstructions(instructions)
LaneGuidanceProviderContinuous -> LaneGuidanceProviderContinuous: instructions_ = instructions

alt When SetAnnouncementPhase is called before SetPosition

  TripService -> LaneGuidanceProviderContinuous: SetAnnouncementPhase(phase)
  LaneGuidanceProviderContinuous -> LaneGuidanceTracker: SetUpcomingManeuver(phase)
  LaneGuidanceTracker -> LaneGuidanceTracker: announcement_phase_ = phase
  TripService -> LaneGuidanceProviderContinuous: SetPosition()
  group#Red Incorrect behaviour
  LaneGuidanceProviderContinuous -> LaneGuidanceProviderContinuous: SetFirstUpcomingManeuver()
  LaneGuidanceProviderContinuous -> LaneGuidanceTracker: SetUpcomingManeuver(kNoAnnouncement)
  LaneGuidanceTracker -> LaneGuidanceTracker: announcement_phase_ = kNoAnnouncement
  end
  LaneGuidanceProviderContinuous -> LaneGuidanceProviderContinuous: SendUpdatedScenario()

else When SetPosition is called first

  TripService -> LaneGuidanceProviderContinuous: SetPosition()
  LaneGuidanceProviderContinuous -> LaneGuidanceProviderContinuous: SetFirstUpcomingManeuver()
  LaneGuidanceProviderContinuous -> LaneGuidanceTracker: SetUpcomingManeuver(kNoAnnouncement)
  LaneGuidanceTracker -> LaneGuidanceTracker: announcement_phase = kNoAnnouncement
  LaneGuidanceProviderContinuous -> LaneGuidanceProviderContinuous: SendUpdatedScenario()
  TripService -> LaneGuidanceProviderContinuous: SetAnnouncementPhase(phase)
  LaneGuidanceProviderContinuous -> LaneGuidanceTracker: SetUpcomingManeuver(phase)
  LaneGuidanceTracker -> LaneGuidanceTracker: announcement_phase_ = phase
  LaneGuidanceProviderContinuous -> LaneGuidanceProviderContinuous: SendUpdatedScenario()

end

==After either case, the\nfollowing requests can occur==

TripService -> LaneGuidanceProviderContinuous: SetPosition()
note right: doesn't change announcement_phase_

TripService -> LaneGuidanceProviderContinuous: SetAnnouncementPhase(phase)
LaneGuidanceProviderContinuous -> LaneGuidanceTracker: SetUpcomingManeuver(phase)
LaneGuidanceTracker -> LaneGuidanceTracker: announcement_phase_ = phase

@enduml

----

== Solution

In order to address this issue, we must ensure that invoking `SetPosition` for
the first time after reset, and after `SetAnnouncementPhase` has been called,
does not lead to overwriting the announcement phase. This can be achieved by
adding a conditional check in the `SetPosition` method to set the first upcoming
maneuver only if it has not already been set earlier.
