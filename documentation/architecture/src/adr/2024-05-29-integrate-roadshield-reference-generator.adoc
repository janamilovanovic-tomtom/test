// Copyright (C) 2024 TomTom NV. All rights reserved.

= Integration of road shield reference generator into the instruction engine

== Context

For the https://jira.tomtomgroup.com/browse/GOSDK-13564[Roadshield support in NIP]
and the https://jira.tomtomgroup.com/browse/GOSDK-13785[Exit shield support in NIP]
the instruction engine needs to emit road shield and exit shield references in the instructions.
The references are generated by a separate component, the
https://github.com/tomtom-internal/roadshield-reference-generator/[road shield reference generator].

== Problem

Road shield references are a part of the RoadShield structure which is populated by the LineImpl in the junction model.
For the LineImpl to be able to populate the RoadShield structure it needs access to the road shield reference generator.

== Proposed solution

The road shield reference generator is injected into the instruction engine as a dependency at the entry points of the instruction engine.
It is the responsibility of the caller to provide the road shield reference generator instance to the instruction engine.
This allows the client to provide the correct version of the road shield reference generator and allow road shield references to change independently from the instruction engine.
For example, the road shield reference generator can be updated to support new versions of the road shield references without the need to update the instruction engine.
At the same time, older clients can still request the older version of the road shield references with the current version of the instruction engine.

A road shield reference generator can be created by the caller by using the
https://github.com/tomtom-internal/roadshield-reference-generator/blob/3516f98a3b208356d031e8827fa79f9713c2ab5d/roadshield-reference-generator/lib/include/tomtom/roadshield/roadshield_reference_generator.hpp#L84[CreateGenerator]
factory function and passed to the instruction engine at the entry point.

The provided road shield reference generator is accepted by `unique_ptr`, so the instruction engine accepts the ownership of the reference generator.

N.b. In the final version of the APIs, we decided to not go with a defaulted parameter for the roadshield reference generator. There is no way for the instruction engine to know what version needs to be constructed, thus we are forcing the caller to provide the reference generator (together with the correct version).

=== Entry point: CreateInstructionProvider (used by the NK2)
`include/tomtom/navkit2/instruction_engine/instruction_provider_factory.hpp`/CreateInstructionProvider

This does not change, since there is no requirement for NK2 to generate references, so it does not need a road shield reference generator.

==== Implementation details
The `InstructionProvider` constructor will take a road shield reference generator, since it is also called from `GetFullInstructionList`.
When an instance of `InstructionProvider` is created via the `CreateInstructionProvider` path, we will pass a no-op road shield reference generator into the `InstructionProvider` constructor.

=== Entry point: CreateInstructionGenerator (used by the NavSDK)
`include/tomtom/navkit2/instruction_engine/instruction_generator.hpp`/CreateInstructionGenerator

```
  template <typename MapAccessTraits>
  std::unique_ptr<InstructionGenerator> CreateInstructionGenerator(
      MapContainerPtr<MapAccessTraits> map_container, const RouteAttributes& route_attributes,
+     std::unique_ptr<tomtom::roadshield::ReferenceGenerator> road_shield_reference_generator,
      LaneGroupResolution lane_group_resolution = LaneGroupResolution::kLinkAndCrossLink,
      const std::string& accumulated_data = "");
```

=== Entry point: GetFullInstructionList (used by the NavKitWorker)
`include/tomtom/navkit2/instruction_engine/get_full_instruction_list.hpp`/GetFullInstructionList

```
  std::vector<Instruction> GetFullInstructionList(
      MapContainerPtr<OnboardMapAccessTraits> map_container,
      ConstIterator<ArcIntKeyWithOffset> route_arcs_begin,
      ConstIterator<ArcIntKeyWithOffset> route_arcs_end, const RouteAttributes& route_attributes,
+     std::unique_ptr<tomtom::roadshield::ReferenceGenerator> road_shield_reference_generator,
      const std::string& route_id, StopCondition stop_condition = kStopConditionNone,
      LaneGroupResolution lane_group_resolution = LaneGroupResolution::kLinkAndCrossLink);
```

```
  std::vector<Instruction> GetFullInstructionList(
      const DataAccess::NDS::CGuidanceData& guidance_data,
      const DataAccess::NDS::CLaneLevel& lane_level,
      ConstIterator<ArcIntKeyWithOffset> route_arcs_begin,
      ConstIterator<ArcIntKeyWithOffset> route_arcs_end, const RouteAttributes& route_attributes,
+     std::unique_ptr<tomtom::roadshield::ReferenceGenerator> road_shield_reference_generator,
      const std::string& route_id, StopCondition stop_condition = kStopConditionNone,
      LaneGroupResolution lane_group_resolution = LaneGroupResolution::kLinkAndCrossLink);
```

`include/tomtom/navkit2/instruction_engine/get_full_instruction_list_nda.hpp`/GetFullInstructionList

```
  std::vector<Instruction> GetFullInstructionList(
      MapContainerPtr<NDAMapAccessTraits> map_container,
      ConstIterator<ArcIntKeyWithOffset> route_arcs_begin,
      ConstIterator<ArcIntKeyWithOffset> route_arcs_end, const RouteAttributes& route_attributes,
+     std::unique_ptr<tomtom::roadshield::ReferenceGenerator> road_shield_reference_generator,
      const std::string& route_id, StopCondition stop_condition = kStopConditionNone,
      LaneGroupResolution lane_group_resolution = LaneGroupResolution::kLinkAndCrossLink);
```

=== Passing the reference generator inside the instruction engine
From the entry points the reference generator is passed to the `JunctionAndLineFactoryImpl` through the `MakeLineOnRouteProvider` factory method, so the ownership is maintained in the JunctionAndLineFactoryImpl.
The `JunctionAndLineFactoryImpl` then passes the generator to the `LineImpl` which populates the `RoadShield` structure.

=== Dependency management

The road shield reference generator is delivered as a separate component. The dependency is declared in the conan files.
Note that the road shield reference generator is now referenced in the public interface of the instruction engine.

```
  # conanfile.py
  requires = (
    # ...
+   "roadshield-reference-generator/[>=0.2.0]@tomtom/stable",
    # ...
  )

  def package_info(self):
      self.cpp_info.components["Interface"].requires = [
          # ...
+         "roadshield-reference-generator::roadshield-reference-generator",
      ]

  # conanfile.ttlock
  # ...
+ roadshield-reference-generator/0.2.0@tomtom/stable

  # CMakeLists.txt
  target_link_libraries(${PROJECT_NAME}-interface
   PUBLIC
    orodoro::attr
    orodoro::quantities
    orodoro::i18n
+   roadshield-reference-generator::roadshield-reference-generator
   PRIVATE
    MAP_ACCESS_CORE
    Boost::boost
    mapdataaccess::common
    tinyxml2::tinyxml2
  )
```

Note that all downstream projects that use the instruction engine (either directly or indirectly) need to add the road shield reference generator to the conanfile.ttlock, similar to the snippet above.
The Renovate bot does not automatically add new dependencies to the conanfile.ttlock, so this needs to be done manually.
