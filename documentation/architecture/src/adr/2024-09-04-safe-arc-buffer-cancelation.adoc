// Copyright (C) 2024 TomTom NV. All rights reserved.

= Arc buffer cancelation

== Abstract

This document proposes throw exceptions when accessing iterators of a canceled NK2 arc buffer
instead of relying on the logic of making all iterators equal to end iterator after the arc buffer is canceled.

== Context

Arc buffer cancellation in NK2 has surfaced as a problem multiple times:

- https://jira.tomtomgroup.com/browse/NAV-79123[NAV-79123 Crash while driving (TTP replay) with an SLG map.]
- https://jira.tomtomgroup.com/browse/HCP3-18540[HCP3-18540 Flaky segmentation fault in trip-service test PlanRouteOnboard_RouteResolved_RepeatedlyRestartingInstructionGenerationThread]
- https://jira.tomtomgroup.com/browse/NAV-112492[NAV-112492 Assertion happens in nk2-navigation-trip tests]
- https://jira.tomtomgroup.com/browse/HCP3-17094[HCP3-17094 Fix disabled flaky tests]
- https://jira.tomtomgroup.com/browse/NAV-36802[NAV-36802 TomTom SDK 12.2.0 SIGSEGV navigation-onboardservice]
It was also falsely accused as the source of the crashes here:
- https://jira.tomtomgroup.com/browse/NAV-144030[NAV-144030 Upgrade to NDK 26.2 -- NIE crash]

== Current approach to arc buffer cancellation in NK2

Right now NK2 when arc buffer iterator is canceled the instruction engine is notified of this condition using iterator behaviour.
When the cancellation happens all iterators of arc buffer become the end iterator.
https://github.com/tomtom-internal/nk2-navigation-trip/blob/19b94ac731153aac50588b5ccd8be6d6577f893b/navigation-trip-onboardservice/navigation/guidance/include/tomtom/sdk/navigation/guidance/arc_buffer_iterator.hpp#L83[arc_buffer_iterator.hpp:83]
Dereferencing end iterator always yields an invalid arc key.

== Problems with current approach

A common theme in the discussions of these issues is that we are not sure that arc buffer cancellation logic is
hardened enough against the problem of all iterators becoming equal to end iterator at any moment in time.

This behaviour leads to several problems:

[cols="1,1,1"]
|===
| Id | Problem | Example problem

| P1
| Dereferencing an arc buffer iterator can always yield an invalid arc key.
| It easy to write unsafe code that passes invalid arc keys to map access.
  E.g. neither RoadStretchFactory nor does LaneGuidanceBuilder check for arc key validity ATM.
  This results in crashes.

| P2
| Distance checks between arc buffer iterators can become outdated at any point in time.
| Example is provided below.

|===

https://github.com/tomtom-internal/navigation-instruction-engine/blob/5830e907740d2d778b18728f5a90135c82e29da6/navigation-instruction-engine/src/lane_guidance/road_stretch_factory.hpp#L120[navigation-instruction-engine/src/lane_guidance/road_stretch_factory.hpp]

.Example of the distance check problem
[source,c++]
----
boost::optional<RoadStretch<MapAccessTraits>> Build() const {
  ...
  // THE CODE BELOW CHECKS IF WE HAVE AT LEAST ONE ARC TO PROCESS
  if (begin_arc == end_arc) {
    return boost::none;
  }
  ...
  // WE COPY THE ARC KEYS FROM THE ITERATORS.
  result.arckeys.reserve(static_cast<std::size_t>(std::distance(begin_arc, end_arc)));
  std::transform(
      begin_arc, end_arc, std::back_inserter(result.arckeys), <----------------------------------- 2
      [this](const ArcOnRouteKeyAndOffsets<ArcIntKey>& arc_int_key_with_offset) {
        ArcOnRouteKeyAndOffsets<typename MapAccessTraits::TArcKey> value;
        value.arc_key = map_container_->ToNativeArcKey(arc_int_key_with_offset.arc_key);
        value.tail_offset_on_route = arc_int_key_with_offset.tail_offset_on_route;
        value.arrival_offset_on_arc = arc_int_key_with_offset.arrival_offset_on_arc;
        value.update_region_version_id = arc_int_key_with_offset.update_region_version_id;
        return value;
      });

  result.offset_on_first_arc =
      std::max(scenario_begin_offset_ - begin_arc->tail_offset_on_route, Centimeters{0});

  // THE CODE BELOW ASSUMES THAT THE VECTOR IS NOT EMPTY
  const auto& last_arc = result.arckeys.back(); <------------------------------------------------- 3
  ...
}
----

== Alternative solutions

=== Be vigiliant.

Make sure that every potential problem with asynchronous arc buffer cancellation is prevented by carefully veryfing
that the all the unsafe code that uses arc iterators directly is safe from dereferencing invalid arc keys and that it handles
the situations where distance between two iterators can suddenly become 0.

So far our experience shows that we were not very successful with this strategy.

This solution leaves us with a risk that:

- Code that handles the cancellation incorrectly may still lurk inside the current instruction engine repository.
- It is possible that future modifications of instruction engine will break this mechanism again, as it is very hard
  to make a reliable test for these race conditions.

=== Suggested solution - use exception handling

Exceptions thrown from the arc buffer after accessing a canceled iterator allow us to immediately abort the computation in
InstructionProvider and LaneGuidanceProvider and not let any of the problems mentioned above happen.

It allows us to forget about the existance of NK2 arc buffer when writing new code for instruction engine,
as long as we catch exceptions in these NK2 specific interface components.

There is a strong criticism of this solution that exceptions should not be used for normal flow control of the application.
However since the original approach of making all iterators equal to end turns out to be a source of confusion and long standing
bugs in our code I would like to ask everyone consider it as a viable compromise that addresses critical problem of the current design.

=== Conclusion

This document suggest the following approach:

- Extend Iterator class with two exceptions. DereferencingInvalidIteratorException will be thrown when trying to dereference a canceled iterator
  and IncrementingInvalidIteratorException that can be thrown when calling the increment operators on the arc buffer iterator.
- In the instruction engine convert these exceptions to ArcIterationAborted inside RoadStretchFactory and LineOnRouteFactor to make the
  cancellation logic work correctly in LaneGuidanceProvider (LaneGuidanceProvider kills its own thread on any other exception).
- In trip-service throw the corresponding exceptions in ArcBuffer after cancellation.
