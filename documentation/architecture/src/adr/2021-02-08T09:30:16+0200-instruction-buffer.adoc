// Copyright (C) 2018 TomTom NV. All rights reserved.
//
// This software is the proprietary copyright of TomTom NV and its subsidiaries and may be
// used for internal evaluation purposes or commercial use strictly subject to separate
// license agreement between you and TomTom NV. If you are the licensee, you are only permitted
// to use this software in accordance with the terms of your license agreement. If you are
// not the licensee, you are not authorized to use this software in any manner and should
// immediately return or destroy it.

= Instruction Buffer

== Status

Proposed

== Context

Currently the instructions are produced by InstructionEngine and consumed by an external
client (OnboardTripGuidanceManager, serializing it for use by the Trip ClientLib).
InstructionProvider is the component where the instructions coming from InstructionEngine
are accumulated, and emitted to the client.

Since recently, InstructionEngine has been producing instructions for each arc at a time.
This results in mostly one instruction at a time, since usually the instructions are generated
per junction, and there is at most one junction generated for an input arc.  However there
might be instructions in the middle of the arc, such as itinerary instructions.  In this case
the InstructionEngine will provide more than one instruction.

The InstructionEngine does not guarantee to provide instructions sorted by offset.  For example,
we intend to generate departure and arrival first, and then fill in the intermediate instructions
later (see https://confluence.tomtomgroup.com/pages/viewpage.action?pageId=880817976).
Yet it is part of InstructionProvider responsibility to provide the instructions to the client
increasingly sorted by offset on route, since it is part of its API contract.

In addition, instructions that are past of current car position (CCP) are no longer of interest
for the client, and therefore should be continuously dropped as we drive.

== Proposal

We propose to encapsulate this logic inside a dedicated instruction buffer class.  It will
have a clear interface allowing:
* Addition of new instructions, while preserving consistent order and distinction with already
existing instructions in the buffer.
* Removal of existing instructions before given offset.
* Retrieval of first (at most) N instructions in the buffer.

Since access to this buffer will be done from multiple threads (both client consumer thread
and instruction engine producer thread), this class will be thread-safe for data access.

A simple implementation would be an underlying associative container based on offset, so
addition of new instructions and removal of existing ones based on offset will be done
efficiently.

== Consequences

* Separation of responsibilities (less code in InstructionProvider)
* Ability to test behavior
* Relaxed interface between internal instruction engine components
