// Copyright (C) 2021 TomTom NV. All rights reserved.
//
// This software is the proprietary copyright of TomTom NV and its subsidiaries and may be
// used for internal evaluation purposes or commercial use strictly subject to separate
// license agreement between you and TomTom NV. If you are the licensee, you are only permitted
// to use this software in accordance with the terms of your license agreement. If you are
// not the licensee, you are not authorized to use this software in any manner and should
// immediately return or destroy it.

= GoSDK Lane Guidance Engine

== Status

Proposed

== Introduction

We have https://jira.tomtomgroup.com/browse/NAV-73220[an epic] to
implement simple lane guidance in Go SDK.  Initially we are
concentrating on the Android implementation, with an iOS
implementation to follow with the same architecture.  We need to
establish an architecture to support this.

== Navigation SDK

Simple lane guidance is already a part of the Navigation SDK.  However
it is only implemented for online routing.  In this case the lane
information is supplied with the route.  All the Navigation
Orchestrator needs to do is respond to position updates by finding the
corresponding lane guidance at that point on the route, and call back
the clients with this information.

To support simple lane guidance in onboard mode, we would like to
maintain that same API for clients.  Since the onboard route does not
contain lane information, the Navigation Orchestrator will need to
compute this lane data itself, onboard, and using the onboard map.

== Functional Enabler

We would like to leverage the existing lane guidance engine used in
NavKit2.  This is a C++ library included in the instruction engine
library.  All of the code has been
https://jira.tomtomgroup.com/browse/NAV-74095[templatized according to
MapAccessTraits], allowing different map implementations to be used.
However, currently only the NK2 onboard map is implemented in the
library.

In GoSDK C\++ code forms "functional enablers", libraries that can
then be bound into Swift/Kotlin and utilised from GoSDK libraries.  So
the C++ lane guidance code can be brought in as one of these
functional enablers.

The instruction engine library is already incorporated into GoSDK as a
functional enabler for onboard instruction generation in the
Routing SDK.  However, it is not ideal to share the same functional
enabler between two different SDKs, since the onboard-directions
functional enabler contains a lot of functionality unnecessary for the
navigation SDK.  Therefore we will add a new functional enabler just
for lane guidance. The new functional enabler resides in the GoSDK
bindings repository

== Lane Guidance Engine

The primary entry point for lane guidance generation in the NavKit2
instruction engine library is the `LaneGuidanceProvider`.  This takes
a sequence of arcs forming the route, and a map.  It creates a
background thread for lane guidance generation.  Here it continually
watches for the next upcoming stretch of lane guidance, and calls the
`LaneGuidanceBuilder` when a new lane guidance scenario is required.

In Go SDK we prefer to avoid creating background threads in functional enablers.
Instead the client is responsible for deciding when work is to be
performed.  Therefore the C++ `LaneGuidanceProvider` implementation
will not be used.  The primary entry point for the functional enabler
will instead be the `LaneGuidanceBuilder`.

This still leaves some tasks previously performed by the
`LaneGuidanceProvider`.  These will be performed by a new Swift/Kotlin
component, the Lane Guidance Engine.  It will respond to changes in
position, as well as the list of upcoming instructions, and perform
the following tasks:

* establish the current route stretch around the next upcoming
  instruction
* call the `LaneGuidanceBuilder` when necessary to build a new lane
  guidance scenario
* update the current lane guidance according to the current position
  on route

Another task that needs to be performed is building a list of the
off-route arcs.  We have not yet decided whether this should be kept
in the functional enabler as a C++ function, or if it should be
re-implemented in Swift/Kotlin as part of the Lane Guidance Engine.

== Accessing the Map

One of the inputs to the `LaneGuidanceBuilder` is the map.  Although
this code is templated according to `MapAccessTraits`, currently we
only have an implementation in the library for the onboard NDS map.

We have established that an onboard NDS map is available to the
Navigation Orchestrator and can be passed to the C++ functional
enablers.

== Obtaining Arc Keys

Another important input to the `LaneGuidanceBuilder` is the list of
arc keys making up the current route.  As of 2020-05-30 the route
object in GoSDK does not contain these arc keys.  They need to be
matched to the onboard map before lane guidance can be computed.

However, it has been decided that
https://confluence.tomtomgroup.com/pages/viewpage.action?spaceKey=GOSDK&title=GO+SDK%3A+Map+References[Map
References will be added to the route object].  Therefore we can
anticipate that these route keys will be available to the Lane
Guidance Engine soon.

== Guidance Engines

Currently online guidance, including lane guidance, is provided by the
guidance engine.  To support onboard lane guidance, we will be
building a new engine in Swift/Kotlin called the "lane guidance
engine", which will provide the lane guidance events to the client
when running in onboard mode.  However, in online mode it will still
be the existing guidance engine that provides these events.

In the future we may wish to rationalise this by either moving online
lane guidance support into the lane guidance engine, or by developing
a new dedicated online lane guidance engine.  However, that
refactoring is not on the critical path for delivering onboard lane
guidance in GoSDK.

== Overall Architecture

image::2022-05-30T10:11:41+0200-gosdk-lane-guidance-engine/onboard_lane_guidance_architecture.jpg[Static,1080]

Diagram taken from https://miro.com/app/board/uXjVOyErEfA=/?share_link_id=852929690951[this Miro board].

== Sequence Diagram

[plantuml, lane-guidance-sequence, svg, alt="Sequence diagram of onboard lane guidance generation"]

....

@startuml

participant PositionUpdates
participant NavigationOrchestrator
participant LaneGuidanceEngine
participant OnboardRoutingClient
participant RouteProjectionEngine
participant onboard_routing_
participant onboard_instructions_
participant onboard_lane_guidance_

OnboardRoutingClient -> onboard_routing_ : planRoute()
...
onboard_routing_ -> OnboardRoutingClient : route polyline
OnboardRoutingClient -> RouteProjectionEngine : route polyline
RouteProjectionEngine -> OnboardRoutingClient : route map references
OnboardRoutingClient -> onboard_instructions_ : fetchInstructions()
onboard_instructions_ -> OnboardRoutingClient : instructions
OnboardRoutingClient -> NavigationOrchestrator : polyline + references + instructions
NavigationOrchestrator -> LaneGuidanceEngine : polyline + references + instructions
LaneGuidanceEngine -> onboard_lane_guidance_ : Generate()
onboard_lane_guidance_ -> LaneGuidanceEngine : lane guidance scenario
...
PositionUpdates -> LaneGuidanceEngine : position update
LaneGuidanceEngine -> NavigationOrchestrator : lane guidance
...
PositionUpdates -> LaneGuidanceEngine : position update
LaneGuidanceEngine -> NavigationOrchestrator : lane guidance

@enduml

....
